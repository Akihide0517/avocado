//
//  FFTController.swift
//  audioavocado -Test
//
//  Created by 吉田成秀 on 2023/10/19.
//

import Foundation
import Accelerate
import AVFoundation
import UIKit

class FFTController: UIViewController {
    
    var windowSize = 512
    var duration = 5.0
    var startFreq = 10.0 // Swiftで小数点が必要
    var endFreq = 24000.0 // Swiftで小数点が必要
    var sampleRate = 48000
    var t: [Double] = []
    var user_name = "FFTSound"
    var nRepetitions = 10
    var results: [[String]] = []

    override func viewDidLoad() {
        super.viewDidLoad()

        // tを生成
        t = stride(from: 0, to: duration, by: 1.0 / Double(sampleRate)).map { $0 }
        
        let R = log(endFreq / startFreq)
        
        // ハミング窓を生成
        var window = [Double](repeating: 0.0, count: windowSize)
        
        for i in 0..<windowSize {
            let value = 0.54 - 0.46 * cos(2.0 * Double.pi * Double(i) / Double(windowSize - 1))
            window[i] = value
        }
        
        let halfWindowSize = windowSize / 2
        for i in 0..<halfWindowSize {
            window[i] = 1.0
        }
        
        for _ in 0..<nRepetitions {
            // シャープ信号生成ロジック
            let outputSignal = generateSharpSignal(duration: duration, startFreq: startFreq, endFreq: endFreq, sampleRate: sampleRate)
            
            // Impulse Responseを生成
            let envelope = t.map { exp($0 * R / duration) }
            var outputSignal: [Double] = [1.0, 2.0, 3.0, 4.0] // 仮の出力信号データ
            outputSignal = outputSignal.reversed() // 出力信号を逆順にする
            let correctedSignal = zip(outputSignal, envelope).map { $0.0 / $0.1 }
            
            // Impulse Response処理
            
            // FFTを実行
            let FFTSetup = vDSP_create_fftsetupD(vDSP_Length(log2(Double(windowSize)), FFTRadix(kFFTRadix2)))
            let impulseResponseFFT = UnsafeMutablePointer<DSPDoubleComplex>.allocate(capacity: windowSize)
            vDSP_ctozD(responseWithWindow, 1, impulseResponseFFT, 2, vDSP_Length(windowSize))
            vDSP_fft_zipD(FFTSetup, impulseResponseFFT, 1, vDSP_Length(windowSize), FFTDirection(FFT_FORWARD))
            
            let amp: [Double] = impulseResponseFFT.map { sqrt($0.re * $0.re + $0.im * $0.im) }
            let phase: [Double] = impulseResponseFFT.map { atan2($0.im, $0.re) }
            let phaseInDegrees = phase.map { $0 * (180.0 / .pi) }
            
            // メモリ解放
            vDSP_destroy_fftsetupD(FFTSetup)
            impulseResponseFFT.deallocate()
            
            for i in 0..<amp.count {
                // ユーザー名にインデックスを追加
                let combined_result = [user_name + "_\(i + 1)"] + amp.map { String($0) } + phase.map { String($0) } + impulse_response.map { String($0) }
                results.append(combined_result)
            }
        }
        
        for i in 0..<nRepetitions {
            // ユーザー名を生成
            let user_name = "User\(i + 1)"
            
            // データを組み合わせた結果データ
            let combined_result = [user_name] + amp.map { String($0) } + phase.map { String($0) } + impulse_response.map { String($0) }
            results.append(combined_result)
        }
        
        // CSVファイルに結果データを書き込み
        let col_names = ["Name"] + (0..<amp.count).map { "Amp_Freq_\($0)" } + (0..<phase.count).map { "Phase_Freq_\($0)" } + (0..<impulse_response.count).map { "Impulse_Signal_\($0)" }
        let filename = "alltaste.csv"
        let csv = CSV(header: col_names, rows: results, delimiter: ",")
        try? csv.write(to: URL(fileURLWithPath: filename))
                              
        // CSVファイルのパス
        let csvFilePath = "alltaste.csv"
        // CSVファイルを読み取る
        if let csvData = readCSVFile(atPath: csvFilePath) {
            for row in csvData {
                let rowData = row.joined(separator: "\t") // タブで区切って表示
                print(rowData)
            }
        }

    }
        
    // CSVファイルからデータを読み取る関数
    func readCSVFile(atPath filePath: String) -> [[String]]? {
        do {
            let contents = try String(contentsOfFile: filePath, encoding: .utf8)
            let rows = contents.components(separatedBy: "\n")
            var data: [[String]] = []
                                                         
            for row in rows {
                let columns = row.components(separatedBy: ",")
                data.append(columns)
            }
                                                         
            return data
            } catch {
                print("CSVファイルの読み込みエラー: \(error.localizedDescription)")
                return nil
            }
    }
}
