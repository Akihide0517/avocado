//
//  FFTController.swift
//  audioavocado -Test
//
//  Created by 吉田成秀 on 2023/10/19.
//

import Foundation
import UIKit
import Accelerate
import DGCharts

class FFTController: UIViewController {
    var chartView: LineChartView!
    
    override func viewDidLoad() {
        super.viewDidLoad()
        print("opend!")
        
        // Create the LineChartView
        chartView = LineChartView()
        chartView.frame = CGRect(x: 20, y: 20, width: 300, height: 200) // Set frame as needed
        view.addSubview(chartView)
        print("Create the LineChartView end")
        
        if(Level == false){
            // 畳み込まれた結果のデータ
            let convolutionResult = [CGFloat](convolution(wave, reversewave))
            print("convolution end")
            
            // ピークの位置を見つける
            let peakIndices = findPeaks(convolutionResult)!
            print("peakIndices end")
            
            // ピークを中心にデータポイントを取り出しFFT（48000個）
            if(!peakMode){
                let extractedData = extractDataAroundPeaks(convolutionResult, peakIndex: peakIndices, dataPointsCount: 48000)
                print("extractedData end")
                
                let fftResult = performFFT(on: extractedData)
                print("fftResult end")
                
                // Prepare data for the chart
                var entries: [ChartDataEntry] = []
                for (index, magnitude) in fftResult.enumerated() {
                    let entry = ChartDataEntry(x: Double(index), y: magnitude)
                    entries.append(entry)
                }
                print("Prepare data for the chart end")
                
                // Create a data set and a data object for the chart
                let dataSet = LineChartDataSet(entries: entries, label: "FFT Magnitudes")
                let data = LineChartData(dataSet: dataSet)
                
                // Customize the chart appearance (optional)
                chartView.xAxis.labelPosition = .bottom
                chartView.rightAxis.enabled = false
                dataSet.drawCirclesEnabled = false
                
                // Set the data for the chart
                chartView.data = data
                print("all opend!")
            }else{
                let extractedData = extractDataAfterPeak(convolutionResult, peakIndex: peakIndices, dataPointsCount: 48000)
                print("extractedData end")
                
                let fftResult = performFFT(on: extractedData)
                print("fftResult end")
                
                // Prepare data for the chart
                var entries: [ChartDataEntry] = []
                for (index, magnitude) in fftResult.enumerated() {
                    let entry = ChartDataEntry(x: Double(index), y: magnitude)
                    entries.append(entry)
                }
                print("Prepare data for the chart end")
                
                // Create a data set and a data object for the chart
                let dataSet = LineChartDataSet(entries: entries, label: "FFT Magnitudes")
                let data = LineChartData(dataSet: dataSet)
                
                // Customize the chart appearance (optional)
                chartView.xAxis.labelPosition = .bottom
                chartView.rightAxis.enabled = false
                dataSet.drawCirclesEnabled = false
                
                // Set the data for the chart
                chartView.data = data
                print("all opend!")
            }
        }else{
            // 畳み込まれた結果のデータ
            let convolutionResult = [CGFloat](elementwiseMultiplication(wave, reversewave))
            print("elementwiseMultiplication end")
            
            // ピークの位置を見つける
            let peakIndices = findPeaks(convolutionResult)!
            print("peakIndices end")
            
            // ピークを中心にデータポイントを取り出しFFT（初期値48000個）
            if(!peakMode){
                let extractedData = extractDataAroundPeaks(convolutionResult, peakIndex: peakIndices, dataPointsCount: 48000)
                print("extractedData end")
                
                let fftResult = performFFT(on: extractedData)
                print("fftResult end")
                
                // Prepare data for the chart
                var entries: [ChartDataEntry] = []
                for (index, magnitude) in fftResult.enumerated() {
                    let entry = ChartDataEntry(x: Double(index), y: magnitude)
                    entries.append(entry)
                }
                print("Prepare data for the chart end")
                
                // Create a data set and a data object for the chart
                let dataSet = LineChartDataSet(entries: entries, label: "FFT Magnitudes")
                let data = LineChartData(dataSet: dataSet)
                
                // Customize the chart appearance (optional)
                chartView.xAxis.labelPosition = .bottom
                chartView.rightAxis.enabled = false
                dataSet.drawCirclesEnabled = false
                
                // Set the data for the chart
                chartView.data = data
                print("all opend!")
            }else{
                let extractedData = extractDataAfterPeak(convolutionResult, peakIndex: peakIndices, dataPointsCount: 48000)
                print("extractedData end")
                
                let fftResult = performFFT(on: extractedData)
                print("fftResult end")
                
                // Prepare data for the chart
                var entries: [ChartDataEntry] = []
                for (index, magnitude) in fftResult.enumerated() {
                    let entry = ChartDataEntry(x: Double(index), y: magnitude)
                    entries.append(entry)
                }
                print("Prepare data for the chart end")
                
                // Create a data set and a data object for the chart
                let dataSet = LineChartDataSet(entries: entries, label: "FFT Magnitudes")
                let data = LineChartData(dataSet: dataSet)
                
                // Customize the chart appearance (optional)
                chartView.xAxis.labelPosition = .bottom
                chartView.rightAxis.enabled = false
                dataSet.drawCirclesEnabled = false
                
                // Set the data for the chart
                chartView.data = data
                print("all opend!")
            }
        }
    }
    
    //以下どちらが正解か不明なため二つ手段を書いておく
    
    //畳み込み
    func convolution(_ signal1: [CGFloat], _ signal2: [CGFloat]) -> [CGFloat] {
        let m = signal1.count
        let n = signal2.count
        let outputLength = m + n - 1
        
        var result = [CGFloat](repeating: 0, count: outputLength)
        
        for i in 0..<outputLength {
            for j in 0..<m {
                if i - j >= 0 && i - j < n {
                    result[i] += signal1[j] * signal2[i - j]
                }
            }
            print("this outputLength end\(i)")
        }
        
        return result
    }
    
    //掛け算
    func elementwiseMultiplication(_ array1: [CGFloat], _ array2: [CGFloat]) -> [CGFloat] {
        // 2つの配列の要素数が異なる場合はエラーを処理する必要があります
        guard array1.count == array2.count else {
            fatalError("配列の長さが一致しません")
        }
        
        var result = [CGFloat]()
        
        for i in 0..<array1.count {
            let product = array1[i] * array2[i]
            result.append(product)
        }
        
        return result
    }
    
    //不明な所ここまで
    
    func findPeaks(_ data: [CGFloat]) -> Int? {
        guard !data.isEmpty else {
            return nil // データが空の場合は nil を返すか、エラー処理を追加することができます
        }

        var peakIndices = [Int]()

        for i in 1..<data.count - 1 {
            if data[i] > data[i - 1] && data[i] > data[i + 1] {
                peakIndices.append(i)
            }
        }

        if let maxPeakIndex = peakIndices.max() {
            return maxPeakIndex
        } else {
            return nil // ピークが見つからない場合は nil を返すか、エラー処理を追加することができます
        }
    }

    func extractDataAroundPeaks(_ data: [CGFloat], peakIndex: Int, dataPointsCount: Int) -> [CGFloat] {
        let segmentCount = dataPointsCount / 2
        var extractedData = [CGFloat]()
        
        let startIndex = Int(max(0, peakIndex - segmentCount))
        let endIndex = Int(min(data.count - 1, peakIndex + segmentCount))
        
        // ピークの周りのデータを抽出して連結
        if startIndex <= endIndex {
            let segmentData = Array(data[startIndex...endIndex])
            extractedData.append(contentsOf: segmentData)
        }
        
        return extractedData
    }
    
    func extractDataAfterPeak(_ data: [CGFloat], peakIndex: Int, dataPointsCount: Int) -> [CGFloat] {
        var extractedData = [CGFloat]()
        
        let startIndex = peakIndex // ピークの位置から始める
        let endIndex = min(data.count - 1, startIndex + dataPointsCount - 1) // ピークから指定のデータポイント数だけ取得
        
        if startIndex <= endIndex {
            let segmentData = Array(data[startIndex...endIndex])
            extractedData.append(contentsOf: segmentData)
        }
        
        return extractedData
    }

    func performFFT(on data: [CGFloat]) -> [Double] {
            var realPart = [Double](repeating: 0.0, count: data.count)
            var imaginaryPart = [Double](repeating: 0.0, count: data.count)
            
            // Convert CGFloat data to Double
            for (index, value) in data.enumerated() {
                realPart[index] = Double(value)
            }
            
            var splitComplex = DSPDoubleSplitComplex(realp: &realPart, imagp: &imaginaryPart)
            
            let log2n = vDSP_Length(log2(Double(data.count)))
            let setup = vDSP_create_fftsetupD(log2n, Int32(FFT_RADIX2))
            vDSP_fft_zipD(setup!, &splitComplex, 1, log2n, FFTDirection(FFT_FORWARD))
            vDSP_destroy_fftsetupD(setup)
            
            // Calculate magnitudes from real and imaginary parts
            var magnitudes = [Double](repeating: 0.0, count: data.count)
            vDSP_zvmagsD(&splitComplex, 1, &magnitudes, 1, vDSP_Length(data.count))
            
            return magnitudes
        }
}

