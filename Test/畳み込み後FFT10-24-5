//
//  FFTController.swift
//  audioavocado -Test
//
//  Created by 吉田成秀 on 2023/10/19.
//

import Foundation
import UIKit
import Accelerate
import DGCharts
import Dispatch
import simd
import TensorSwift

class FFTController: UIViewController {
    var chartView: LineChartView!
    
    override func viewDidLoad() {
        super.viewDidLoad()
        print("opend!")
        
        // Create the LineChartView
        chartView = LineChartView()
        chartView.frame = CGRect(x: 20, y: 20, width: 300, height: 200) // Set frame as needed
        view.addSubview(chartView)
        print("Create the LineChartView end")
        
        if(wave.count <= 0){
            wave = [1,1,1,1,1,1,1,1,1,1,1]
            reversewave = [2,2,2,2,2,2,2,2,2,2,2]
        }
        
        if(Level == false){
            // 畳み込まれた結果のデータ
            print("wave:",wave.count)
            let convolutionResult = (overlapAddConvolution(signal1: wave.map { Float($0) }, signal2: reversewave.map { Float($0) }, blockSize: 200))
            print("convolution end",convolutionResult.count)
            
            // ピークの位置を見つける
            let peakIndices = findPeaks(convolutionResult.map { CGFloat($0) })!
            print("peakIndices end")
            
            // ピークを中心にデータポイントを取り出しFFT（48000個）
            if(!peakMode){
                let extractedData = extractDataAroundPeaks(convolutionResult.map { CGFloat($0) }, peakIndex: peakIndices, dataPointsCount: 48000)
                print("extractedData end")
                
                let fftResult = performFFT(on: extractedData)
                print("fftResult end")
                
                // Prepare data for the chart
                var entries: [ChartDataEntry] = []
                for (index, magnitude) in fftResult.enumerated() {
                    let entry = ChartDataEntry(x: Double(index), y: magnitude)
                    entries.append(entry)
                }
                print("Prepare data for the chart end")
                
                // Create a data set and a data object for the chart
                let dataSet = LineChartDataSet(entries: entries, label: "FFT Magnitudes")
                let data = LineChartData(dataSet: dataSet)
                
                // Customize the chart appearance (optional)
                chartView.xAxis.labelPosition = .bottom
                chartView.rightAxis.enabled = false
                dataSet.drawCirclesEnabled = false
                
                // Set the data for the chart
                chartView.data = data
                print("all opend!")
            }else{
                let extractedData = extractDataAfterPeak(convolutionResult.map { CGFloat($0) }, peakIndex: peakIndices, dataPointsCount: 48000)
                print("extractedData end")
                
                let fftResult = performFFT(on: extractedData)
                print("fftResult end")
                
                // Prepare data for the chart
                var entries: [ChartDataEntry] = []
                for (index, magnitude) in fftResult.enumerated() {
                    let entry = ChartDataEntry(x: Double(index), y: magnitude)
                    entries.append(entry)
                }
                print("Prepare data for the chart end")
                
                // Create a data set and a data object for the chart
                let dataSet = LineChartDataSet(entries: entries, label: "FFT Magnitudes")
                let data = LineChartData(dataSet: dataSet)
                
                // Customize the chart appearance (optional)
                chartView.xAxis.labelPosition = .bottom
                chartView.rightAxis.enabled = false
                dataSet.drawCirclesEnabled = false
                
                // Set the data for the chart
                chartView.data = data
                print("all opend!")
            }
        }else{
            // 畳み込まれた結果のデータ
            let convolutionResult = [CGFloat](elementwiseMultiplication(wave, reversewave))
            print("elementwiseMultiplication end")
            
            // ピークの位置を見つける
            let peakIndices = findPeaks(convolutionResult)!
            print("peakIndices end")
            
            // ピークを中心にデータポイントを取り出しFFT（初期値48000個）
            if(!peakMode){
                let extractedData = extractDataAroundPeaks(convolutionResult, peakIndex: peakIndices, dataPointsCount: 48000)
                print("extractedData end")
                
                let fftResult = performFFT(on: extractedData)
                print("fftResult end")
                
                // Prepare data for the chart
                var entries: [ChartDataEntry] = []
                for (index, magnitude) in fftResult.enumerated() {
                    let entry = ChartDataEntry(x: Double(index), y: magnitude)
                    entries.append(entry)
                }
                print("Prepare data for the chart end")
                
                // Create a data set and a data object for the chart
                let dataSet = LineChartDataSet(entries: entries, label: "FFT Magnitudes")
                let data = LineChartData(dataSet: dataSet)
                
                // Customize the chart appearance (optional)
                chartView.xAxis.labelPosition = .bottom
                chartView.rightAxis.enabled = false
                dataSet.drawCirclesEnabled = false
                
                // Set the data for the chart
                chartView.data = data
                print("all opend!")
            }else{
                let extractedData = extractDataAfterPeak(convolutionResult, peakIndex: peakIndices, dataPointsCount: 48000)
                print("extractedData end")
                
                let fftResult = performFFT(on: extractedData)
                print("fftResult end")
                
                // Prepare data for the chart
                var entries: [ChartDataEntry] = []
                for (index, magnitude) in fftResult.enumerated() {
                    let entry = ChartDataEntry(x: Double(index), y: magnitude)
                    entries.append(entry)
                }
                print("Prepare data for the chart end")
                
                // Create a data set and a data object for the chart
                let dataSet = LineChartDataSet(entries: entries, label: "FFT Magnitudes")
                let data = LineChartData(dataSet: dataSet)
                
                // Customize the chart appearance (optional)
                chartView.xAxis.labelPosition = .bottom
                chartView.rightAxis.enabled = false
                dataSet.drawCirclesEnabled = false
                
                // Set the data for the chart
                chartView.data = data
                print("all opend!")
            }
        }
        
        let currentDate = Date()  // 現在の日時を取得
        let dateFormatter = DateFormatter()

        dateFormatter.dateFormat = "yyyy-MM-dd HH:mm:ss"  // 任意の日付/時間フォーマットを指定
        let formattedDate = dateFormatter.string(from: currentDate)

        print("現在の時刻は: \(formattedDate)")
    }
    
    //以下どちらが正解か不明なため二つ手段を書いておく
    
    func convolution(signal1: [Float], signal2: [Float]) -> [Float] {
        let m = signal1.count
        let n = signal2.count
        let outputLength = m + n - 1
        
        var result = [Float](repeating: 0.0, count: outputLength)
        var signal1Padded = signal1 + [Float](repeating: 0.0, count: outputLength - m)
        let signal2Reversed = Array(signal2.reversed())
        
        vDSP_conv(signal1Padded, 1, signal2Reversed, 1, &result, 1, vDSP_Length(outputLength), vDSP_Length(n))
        print("convolution() end",result.count)
        
        return result
    }

    func overlapAddConvolution(signal1: [Float], signal2: [Float], blockSize: Int) -> [Float] {
        let m = signal1.count
        let n = signal2.count
        let outputLength = m + n - 1

        var result = [Float](repeating: 0.0, count: outputLength)

        var index = 0
        while index < m {
            let blockEnd = min(index + blockSize, m)
            let currentBlockSize = blockEnd - index
            var block1 = Array(signal1[index..<index + currentBlockSize])
            var block2 = Array(signal2[index..<index + currentBlockSize])

            // Apply convolution for the current block
            let blockResult = convolution(signal1: block1, signal2: block2)

            // Add the block result to the overall result with overlap
            for j in 0..<currentBlockSize {
                result[index + j] += blockResult[j]
            }

            index += currentBlockSize
        }

        // Trim the result to the original output length
        let trimmedResult = Array(result.prefix(outputLength))
        print("overlapAddConvolution end",trimmedResult.count)

        return inverseConvolution(signal: trimmedResult, kernel: signal2)
    }
    
    func inverseConvolution(signal: [Float], kernel: [Float]) -> [Float] {
        let signalLength = signal.count
        let kernelLength = kernel.count
        let outputLength = signalLength + kernelLength - 1
        
        var result = [Float](repeating: 0.0, count: outputLength)
        
        // Apply inverse convolution using Fourier transform
        vDSP_conv(signal, 1, kernel, 1, &result, 1, vDSP_Length(outputLength), vDSP_Length(kernelLength))
        print("inverseConvolution end",result.count)
        
        return result
    }

    //掛け算
    func elementwiseMultiplication(_ array1: [CGFloat], _ array2: [CGFloat]) -> [CGFloat] {
        // 2つの配列の要素数が異なる場合はエラーを処理する必要があります
        guard array1.count == array2.count else {
            fatalError("配列の長さが一致しません")
        }
        
        var result = [CGFloat]()
        
        for i in 0..<array1.count {
            let product = array1[i] * array2[i]
            result.append(product)
        }
        
        return result
    }
    
    //不明な所ここまで
    
    func findPeaks(_ data: [CGFloat]) -> Int? {
        guard !data.isEmpty else {
            return nil // データが空の場合は nil を返すか、エラー処理を追加することができます
        }

        var peakIndices = [Int]()

        for i in 1..<data.count - 1 {
            if data[i] > data[i - 1] && data[i] > data[i + 1] {
                peakIndices.append(i)
            }
        }

        if let maxPeakIndex = peakIndices.max() {
            return maxPeakIndex
        } else {
            return nil // ピークが見つからない場合は nil を返すか、エラー処理を追加することができます
        }
    }

    func extractDataAroundPeaks(_ data: [CGFloat], peakIndex: Int, dataPointsCount: Int) -> [CGFloat] {
        let segmentCount = dataPointsCount / 2
        var extractedData = [CGFloat]()
        
        let startIndex = Int(max(0, peakIndex - segmentCount))
        let endIndex = Int(min(data.count - 1, peakIndex + segmentCount))
        
        // ピークの周りのデータを抽出して連結
        if startIndex <= endIndex {
            let segmentData = Array(data[startIndex...endIndex])
            extractedData.append(contentsOf: segmentData)
        }
        
        return extractedData
    }
    
    func extractDataAfterPeak(_ data: [CGFloat], peakIndex: Int, dataPointsCount: Int) -> [CGFloat] {
        var extractedData = [CGFloat]()
        
        let startIndex = peakIndex // ピークの位置から始める
        let endIndex = min(data.count - 1, startIndex + dataPointsCount - 1) // ピークから指定のデータポイント数だけ取得
        
        if startIndex <= endIndex {
            let segmentData = Array(data[startIndex...endIndex])
            extractedData.append(contentsOf: segmentData)
        }
        
        return extractedData
    }

    func performFFT(on data: [CGFloat]) -> [Double] {
            var realPart = [Double](repeating: 0.0, count: data.count)
            var imaginaryPart = [Double](repeating: 0.0, count: data.count)
            
            // Convert CGFloat data to Double
            for (index, value) in data.enumerated() {
                realPart[index] = Double(value)
            }
            
            var splitComplex = DSPDoubleSplitComplex(realp: &realPart, imagp: &imaginaryPart)
            
            let log2n = vDSP_Length(log2(Double(data.count)))
            let setup = vDSP_create_fftsetupD(log2n, Int32(FFT_RADIX2))
            vDSP_fft_zipD(setup!, &splitComplex, 1, log2n, FFTDirection(FFT_FORWARD))
            vDSP_destroy_fftsetupD(setup)
            
            // Calculate magnitudes from real and imaginary parts
            var magnitudes = [Double](repeating: 0.0, count: data.count)
            vDSP_zvmagsD(&splitComplex, 1, &magnitudes, 1, vDSP_Length(data.count))
            
            return magnitudes
        }
}
