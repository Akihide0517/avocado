//
//  FFTController.swift
//  audioavocado -Test
//
//  Created by 吉田成秀 on 2023/10/19.
//

import Foundation
import UIKit
import Accelerate
import DGCharts

class FFTController: UIViewController {
    var chartView: LineChartView!
    
    override func viewDidLoad() {
        super.viewDidLoad()
        print("opend!")
        
        // Create the LineChartView
        chartView = LineChartView()
        chartView.frame = CGRect(x: 20, y: 20, width: 300, height: 200) // Set frame as needed
        view.addSubview(chartView)
        print("Create the LineChartView end")
        
        // 畳み込まれた結果のデータ
        let convolutionResult = [CGFloat](convolution(wave, reversewave))
        print("convolutionResult end")

        // ピークの位置を見つける
        let peakIndices = findPeaks(convolutionResult)
        print("peakIndices end")

        // ピークを中心にデータポイントを取り出しFFT（48000個）
        let extractedData = extractDataAroundPeaks(convolutionResult, peakIndices: peakIndices, dataPointsCount: 48000)
        let fftResult = performFFT(on: extractedData)
        print("extractedData end")
        
        // Prepare data for the chart
        var entries: [ChartDataEntry] = []
        for (index, magnitude) in fftResult.enumerated() {
            let entry = ChartDataEntry(x: Double(index), y: magnitude)
            entries.append(entry)
        }
        print("Prepare data for the chart end")

        // Create a data set and a data object for the chart
        let dataSet = LineChartDataSet(entries: entries, label: "FFT Magnitudes")
        let data = LineChartData(dataSet: dataSet)

        // Customize the chart appearance (optional)
        chartView.xAxis.labelPosition = .bottom
        chartView.rightAxis.enabled = false

        // Set the data for the chart
        chartView.data = data
        print("all opend!")
    }
    
    func convolution(_ signal1: [CGFloat], _ signal2: [CGFloat]) -> [CGFloat] {
        let m = signal1.count
        let n = signal2.count
        let outputLength = m + n - 1
        
        var result = [CGFloat](repeating: 0, count: outputLength)
        
        for i in 0..<outputLength {
            for j in 0..<m {
                if i - j >= 0 && i - j < n {
                    result[i] += signal1[j] * signal2[i - j]
                }
            }
            print("this outputLength end")
        }
        
        return result
    }
    
    func findPeaks(_ data: [CGFloat]) -> [Int] {
        var peakIndices = [Int]()
        
        for i in 1..<data.count - 1 {
            if data[i] > data[i - 1] && data[i] > data[i + 1] {
                peakIndices.append(i)
            }
        }
        
        return peakIndices
    }

    func extractDataAroundPeaks(_ data: [CGFloat], peakIndices: [Int], dataPointsCount: Int) -> [CGFloat] {
        var extractedData = [CGFloat]()
        
        for peakIndex in peakIndices {
            let startIndex = max(0, peakIndex - dataPointsCount / 2)
            let endIndex = min(data.count - 1, startIndex + dataPointsCount - 1)
            let extractedSegment = Array(data[startIndex...endIndex])
            extractedData.append(contentsOf: extractedSegment)
        }
        
        return extractedData
    }
    
    func performFFT(on data: [CGFloat]) -> [Double] {
            var realPart = [Double](repeating: 0.0, count: data.count)
            var imaginaryPart = [Double](repeating: 0.0, count: data.count)
            
            // Convert CGFloat data to Double
            for (index, value) in data.enumerated() {
                realPart[index] = Double(value)
            }
            
            var splitComplex = DSPDoubleSplitComplex(realp: &realPart, imagp: &imaginaryPart)
            
            let log2n = vDSP_Length(log2(Double(data.count)))
            let setup = vDSP_create_fftsetupD(log2n, Int32(FFT_RADIX2))
            vDSP_fft_zipD(setup!, &splitComplex, 1, log2n, FFTDirection(FFT_FORWARD))
            vDSP_destroy_fftsetupD(setup)
            
            // Calculate magnitudes from real and imaginary parts
            var magnitudes = [Double](repeating: 0.0, count: data.count)
            vDSP_zvmagsD(&splitComplex, 1, &magnitudes, 1, vDSP_Length(data.count))
            
            return magnitudes
        }
}

